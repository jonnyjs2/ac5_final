<!DOCTYPE html>
<html lang="en-US">
<head>
    <meta charset="utf-8">
    <title>Seattle Parks</title>
    <meta name="viewport" content="initial-scale=1,maximum-scale=1,user-scalable=no">

    <link href='https://api.mapbox.com/mapbox-gl-js/v2.5.0/mapbox-gl.css' rel='stylesheet' /> 
    <script src="https://api.mapbox.com/mapbox-gl-js/v2.5.0/mapbox-gl.js"></script>

    
    <link rel="stylesheet" href="css/map.css">
    <link rel="stylesheet" href="css/main.css">

    <style>
        .mapboxgl-popup {
            max-width: 250px;
            font-family: 'Open Sans', Arial, sans-serif;
        }
        
        .mapboxgl-popup-content {
            padding: 12px;
            background: rgba(255, 255, 255, 0.95);
            border-radius: 8px;
            box-shadow: 0 3px 10px rgba(0,0,0,0.2);
        }
        
        .mapboxgl-popup-close-button {
            display: none; 
        }
        
        .popup-title {
            font-size: 15px;
            font-weight: bold;
            margin-bottom: 6px;
            color: #2ecc71;
            padding-bottom: 4px;
            border-bottom: 1px solid #2ecc71;
        }
        
        .popup-info {
            font-size: 13px;
            color: #333;
            margin: 4px 0;
        }
        
        .popup-label {
            font-weight: 600;
            color: #666;
        }
        
        /* Nur: User location marker styles start */
        .user-location-marker {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background-color: #4285f4;
            border: 3px solid #ffffff;
            box-shadow: 0 2px 6px rgba(0,0,0,0.3);
            position: relative;
        }
        
        .user-location-marker::before {
            content: '';
            position: absolute;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background-color: #4285f4;
            opacity: 0.4;
            animation: pulse 2s infinite;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            margin: 0;
        }
        
        @keyframes pulse {
            0% {
                transform: translate(-50%, -50%) scale(1);
                opacity: 0.4;
            }
            50% {
                transform: translate(-50%, -50%) scale(2);
                opacity: 0;
            }
            100% {
                transform: translate(-50%, -50%) scale(2);
                opacity: 0;
            }
        }
        /* Nur: User location marker styles end */
    </style>
</head>

<body>

    <header>
        <nav>
            <a href="index.html" class="logo">GreenSpace Finder</a>
            <div class="nav-links">
                <a href="index.html">Home</a>
                <a href="map.html" aria-current="page">Map</a>
                <a href="sources.html">Sources</a>
            </div>
        </nav>
    </header>



    <button id="toggle-panel" aria-expanded="false" aria-controls="side-panel" aria-label="Toggle parks list panel">Parks</button>
    <div id="panel-overlay" aria-hidden="true"></div>

    <main id="container">

        <div id="side-panel">
            <h2 id="parks-title">Seattle Parks</h2>

            <!-- Nur: Radius filter feature start -->
            <div id="radius-filter-container" style="margin-bottom: 15px; padding: 12px; background: #f8fafc; border-radius: 8px; border: 1px solid rgba(0,0,0,0.1);">
                <label for="radius-input" style="display: block; margin-bottom: 8px; font-weight: 600; color: #1f2937; font-size: 14px;">
                    Filter by Radius (miles):
                </label>
                <div style="display: flex; align-items: center; gap: 10px;">
                    <input type="range" id="radius-input" min="0" max="10" step="0.5" value="0" 
                           style="flex: 1; cursor: pointer;">
                    <span id="radius-value" style="font-weight: 600; color: #1e90ff; min-width: 50px; text-align: right;">0</span>
                </div>
                <div style="margin-top: 8px; font-size: 12px; color: #666;">
                    <span id="filter-status">Showing all parks</span>
                </div>
                <button id="use-location-btn" style="width: 100%; margin-top: 8px; font-size: 12px; padding: 8px;">
                    Use My Location
                </button>
            </div>
            <!-- Nur: Radius filter feature end -->

            <button id="sort-btn">Sort by PMA (desc)</button>
            <button id="sort-distance-btn">Sort by Distance</button>

            <div class="table-container">
                <table id="parks-table-head" class="parks-table">
                    <colgroup>
                        <col style="width:48%" />
                        <col style="width:16%" />
                        <col style="width:18%" />
                        <col style="width:18%" />
                    </colgroup>
                    <thead>
                        <tr>
                            <th><span class="header-label">Park Name</span></th>
                            <th><span class="header-label">PMA</span></th>
                            <th>
                                <span class="header-label">Area</span>
                                <span class="header-unit">(sq.m)</span>
                            </th>
                            <th>
                                <span class="header-label">Distance</span>
                                <span class="header-unit">(mi)</span>
                            </th>
                        </tr>
                    </thead>
                </table>

                <div class="table-body-wrapper">
                    <table id="parks-table" class="parks-table">
                        <colgroup>
                            <col style="width:48%" />
                            <col style="width:16%" />
                            <col style="width:18%" />
                            <col style="width:18%" />
                        </colgroup>
                        <tbody id="parks-tbody">
                        </tbody>
                    </table>
                </div>
            </div>
        </div>

        <div id="map"></div>
    </main>

    <script>
        mapboxgl.accessToken =
            'pk.eyJ1Ijoiam9ubnlqczIiLCJhIjoiY21oZG56a3h5MDUybzJscHU5dDlveHEyMyJ9.Zj4MO5kQbqLf6QDwWWTs2A';

        let map = new mapboxgl.Map({
            container: 'map',
            style: 'mapbox://styles/mapbox/outdoors-v12',
            zoom: 11,
            center: [-122.335167, 47.608013]
        });

        // Sort by distance button behavior (ascending). Requires distances to be present.
        const sortDistanceBtn = document.getElementById('sort-distance-btn');
        if (sortDistanceBtn) {
                sortDistanceBtn.addEventListener('click', function () {
                const tbody = document.getElementById('parks-tbody');
                const rows = Array.from(tbody.rows);
                rows.sort((a, b) => {
                    const da = parseFloat(a.dataset.distance || Infinity);
                    const db = parseFloat(b.dataset.distance || Infinity);
                    return da - db;
                });
                // re-append rows in sorted order
                rows.forEach(r => tbody.appendChild(r));
            });
        }

        let popup = new mapboxgl.Popup({
            closeButton: false,
            closeOnClick: false,
            offset: 10
        });

        // Nur: Radius filter feature start - variables
        let allParksData = null; // Store original parks data
        let userLocation = null; // Store user's location [lng, lat]
        let currentRadius = 0; // Current filter radius in miles
        let userLocationMarker = null; // Store user location marker
        let locationExplicitlySet = false; // Track if user explicitly set location (not just map center)

        // Nur: Calculate distance between two coordinates using Haversine formula
        function calculateDistance(lat1, lon1, lat2, lon2) {
            const R = 3959; // Earth's radius in miles
            const dLat = (lat2 - lat1) * Math.PI / 180;
            const dLon = (lon2 - lon1) * Math.PI / 180;
            const a = 
                Math.sin(dLat / 2) * Math.sin(dLat / 2) +
                Math.cos(lat1 * Math.PI / 180) * Math.cos(lat2 * Math.PI / 180) *
                Math.sin(dLon / 2) * Math.sin(dLon / 2);
            const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
            return R * c;
        }

        // Nur: Filter parks based on radius from user location
        function filterParksByRadius(parksData, centerLocation, radiusMiles) {
            if (!centerLocation || radiusMiles === 0) {
                return parksData; // Return all parks if no location or radius is 0
            }

            const filteredFeatures = parksData.features.filter(feature => {
                const parkCoords = feature.geometry.coordinates;
                const distance = calculateDistance(
                    centerLocation[1], // lat
                    centerLocation[0], // lng
                    parkCoords[1],     // park lat
                    parkCoords[0]      // park lng
                );
                return distance <= radiusMiles;
            });

            return {
                type: 'FeatureCollection',
                features: filteredFeatures
            };
        }

        // Nur: Update map and table with filtered parks
        function updateFilteredParks(filteredParks) {
            // Update map source
            if (map.getSource('parks')) {
                map.getSource('parks').setData(filteredParks);
            }

            // Update table
            let tbody = document.getElementById('parks-tbody');
            // Remove all rows from tbody
            tbody.innerHTML = '';

            // Add filtered parks to table
            for (let feature of filteredParks.features) {
                let row = tbody.insertRow(-1);
                row.insertCell(0).innerHTML = feature.properties.NAME;
                row.insertCell(1).innerHTML = feature.properties.PMA;
                row.insertCell(2).innerHTML = feature.properties.PARKSBND_AREA.toFixed(0);
                let dcell = row.insertCell(3);
                dcell.className = 'distance-cell';
                if (userLocation) {
                    const parkCoords = feature.geometry.coordinates;
                    const dist = calculateDistance(userLocation[1], userLocation[0], parkCoords[1], parkCoords[0]);
                    dcell.innerText = dist.toFixed(2);
                    row.dataset.distance = dist;
                } else {
                    dcell.innerText = '—';
                    row.dataset.distance = Infinity;
                }
            }
        }

        // Nur: Add or update user location marker on map
        function updateUserLocationMarker(location) {
            // Remove existing marker if it exists
            if (userLocationMarker) {
                userLocationMarker.remove();
            }
            
            // Create marker element
            const el = document.createElement('div');
            el.className = 'user-location-marker';
            
            // Create and add marker to map
            userLocationMarker = new mapboxgl.Marker(el)
                .setLngLat(location)
                .addTo(map);
        }

        // Nur: Radius filter feature end

        async function geojsonFetch() {
            let response, parks, neighborhoods;

            response = await fetch('assets/parks.geojson');
            parks = await response.json();

            // Nur: Store original parks data for filtering
            allParksData = parks;

            response = await fetch('assets/neighborhoods.geojson');
            neighborhoods = await response.json();

            let tbody = document.getElementById('parks-tbody');

            for (let feature of parks.features) {
                let row = tbody.insertRow(-1);
                // store park index for reference
                row.dataset.parkIndex = parks.features.indexOf(feature);
                row.insertCell(0).innerHTML = feature.properties.NAME;
                row.insertCell(1).innerHTML = feature.properties.PMA;
                row.insertCell(2).innerHTML = feature.properties.PARKSBND_AREA.toFixed(0);
                // distance cell (miles) - will be computed if we have a userLocation
                let dcell = row.insertCell(3);
                dcell.className = 'distance-cell';
                dcell.innerText = '—';
            }

            // compute initial distances based on current map center (if available)
            try {
                const center = map.getCenter().toArray();
                updateAllDistances(center);
            } catch (e) {
                // map may not be ready yet; distances will update when location is set
            }

            map.on('load', function () {
                // Nur: Initialize user location to map center
                userLocation = map.getCenter().toArray();

                map.addSource('parks', { type: 'geojson', data: parks });
                map.addLayer({
                    id: 'parks-layer',
                    type: 'circle',
                    source: 'parks',
                    paint: {
                        'circle-radius': 6,
                        'circle-color': '#2ecc71',
                        'circle-stroke-color': '#1abc9c',
                        'circle-stroke-width': 2
                    }
                });

                map.addSource('neighborhoods', { type: 'geojson', data: neighborhoods });
                map.addLayer({
                    id: 'neighborhoods-layer',
                    type: 'fill',
                    source: 'neighborhoods',
                    paint: {
                        'fill-color': '#3498db',
                        'fill-opacity': 0.3
                    }
                });

                // ===== HOVER POPUP FEATURE START =====
                
                // Change cursor to pointer when hovering over a park
                map.on('mouseenter', 'parks-layer', function (e) {
                    map.getCanvas().style.cursor = 'pointer';
                    
                    // Get park properties from the GeoJSON
                    const properties = e.features[0].properties;
                    const coordinates = e.features[0].geometry.coordinates.slice();
                    
                    // Convert area from square meters to acres for display
                    const areaInAcres = (properties.PARKSBND_AREA * 0.000247105).toFixed(2);
                    
                    // Build popup HTML with park information
                    let popupHTML = `
                        <div class="popup-title">${properties.NAME || 'Unknown Park'}</div>
                        <div class="popup-info">
                            <span class="popup-label">PMA Score:</span> ${properties.PMA || 'N/A'}
                        </div>
                        <div class="popup-info">
                            <span class="popup-label">Area:</span> ${areaInAcres} acres
                        </div>
                    `;
                    
                    // Add quality level if it exists in the data
                    if (properties.SDQL) {
                        popupHTML += `
                            <div class="popup-info">
                                <span class="popup-label">Quality:</span> ${properties.SDQL}
                            </div>
                        `;
                    }
                    
                    // Ensure popup appears at correct location if map is zoomed out
                    while (Math.abs(e.lngLat.lng - coordinates[0]) > 180) {
                        coordinates[0] += e.lngLat.lng > coordinates[0] ? 360 : -360;
                    }
                    
                    // Display the popup at the park location
                    popup.setLngLat(coordinates)
                        .setHTML(popupHTML)
                        .addTo(map);
                });

                // Remove popup and reset cursor when mouse leaves a park
                map.on('mouseleave', 'parks-layer', function () {
                    map.getCanvas().style.cursor = '';
                    popup.remove();
                });
                
                // ===== HOVER POPUP FEATURE END =====
            });
        }

        geojsonFetch();

        // Update all distance cells using a center [lng, lat]
        function updateAllDistances(center) {
            if (!center) return;
                const tbody = document.getElementById('parks-tbody');
                const rows = Array.from(tbody.rows);
            rows.forEach((row) => {
                const parkIdx = row.dataset.parkIndex;
                if (parkIdx !== undefined && allParksData && allParksData.features[parkIdx]) {
                    const coords = allParksData.features[parkIdx].geometry.coordinates;
                    const dist = calculateDistance(center[1], center[0], coords[1], coords[0]);
                    const cell = row.querySelector('.distance-cell');
                    if (cell) cell.innerText = dist.toFixed(2);
                    row.dataset.distance = dist;
                }
            });
        }

        const sortBtn = document.getElementById("sort-btn");

        sortBtn.addEventListener("click", function () {
            // More efficient sort: read rows into array, sort in-memory,
            // then re-append using a DocumentFragment to minimize DOM reflows.
            const tbody = document.getElementById('parks-tbody');
            const rows = Array.from(tbody.rows);

            rows.sort((a, b) => {
                const pa = parseFloat(a.cells[1].textContent) || 0;
                const pb = parseFloat(b.cells[1].textContent) || 0;
                // sort descending by PMA
                return pb - pa;
            });

            const frag = document.createDocumentFragment();
            rows.forEach(r => frag.appendChild(r));
            tbody.appendChild(frag);
        });

        const sidebar = document.getElementById("side-panel");
        const toggleBtn = document.getElementById("toggle-panel");
        const overlay = document.getElementById("panel-overlay");

        const isMobileViewport = () => window.innerWidth <= 768;
        const setToggleOffset = (isOpen) => {
            if (!isMobileViewport()) {
                toggleBtn.style.bottom = '';
                toggleBtn.classList.remove("shifted");
                return;
            }
            if (isOpen) {
                const panelRect = sidebar.getBoundingClientRect();
                const gap = 14;
                const maxOffset = Math.max(panelRect.height + gap, 160);
                const cappedOffset = Math.min(maxOffset, window.innerHeight - 72);
                toggleBtn.style.bottom = `${cappedOffset}px`;
                toggleBtn.classList.add("shifted");
            } else {
                toggleBtn.style.bottom = '14px';
                toggleBtn.classList.remove("shifted");
            }
        };
        const syncPanelState = (isOpen) => {
            toggleBtn.setAttribute("aria-expanded", String(isOpen));
            overlay.setAttribute("aria-hidden", String(!(isOpen && isMobileViewport())));
            toggleBtn.classList.toggle("shifted", isOpen && isMobileViewport());
            overlay.classList.toggle("active", isOpen && isMobileViewport());
            setToggleOffset(isOpen);
        };

        // Start collapsed on mobile devices
        if (isMobileViewport()) {
            sidebar.classList.add("collapsed");
            syncPanelState(false);
        } else {
            sidebar.classList.remove("collapsed");
            syncPanelState(true);
        }

        toggleBtn.addEventListener("click", () => {
            const willOpen = sidebar.classList.contains("collapsed");
            sidebar.classList.toggle("collapsed");
            syncPanelState(willOpen);
        });

        overlay.addEventListener("click", () => {
            sidebar.classList.add("collapsed");
            syncPanelState(false);
            toggleBtn.focus();
        });

        window.addEventListener("resize", () => {
            if (isMobileViewport()) {
                syncPanelState(!sidebar.classList.contains("collapsed"));
            } else {
                sidebar.classList.remove("collapsed");
                syncPanelState(true);
            }
        });

        // initial position on load
        syncPanelState(!sidebar.classList.contains("collapsed"));

        // Nur: Radius filter feature start - event listeners
        const radiusInput = document.getElementById("radius-input");
        const radiusValue = document.getElementById("radius-value");
        const filterStatus = document.getElementById("filter-status");
        const useLocationBtn = document.getElementById("use-location-btn");

        // Update radius display value
        radiusInput.addEventListener("input", function() {
            const radius = parseFloat(radiusInput.value);
            radiusValue.textContent = radius.toFixed(1);
            currentRadius = radius;
            
            // Apply filter if we have a location
            if (userLocation && allParksData) {
                const filteredParks = filterParksByRadius(allParksData, userLocation, radius);
                updateFilteredParks(filteredParks);
                
                // Update status message
                if (radius > 0) {
                    filterStatus.textContent = `Showing ${filteredParks.features.length} parks within ${radius.toFixed(1)} miles`;
                } else {
                    filterStatus.textContent = "Showing all parks";
                }
            }
        });

        // Get user's current location or clear if already set
        useLocationBtn.addEventListener("click", function() {
            // If location is explicitly set, clear it
            if (locationExplicitlySet && userLocationMarker) {
                // Remove marker
                userLocationMarker.remove();
                userLocationMarker = null;
                locationExplicitlySet = false;
                
                // Reset to Seattle center
                const seattleCenter = [-122.335167, 47.608013];
                userLocation = seattleCenter;
                
                // Fly back to Seattle center
                map.flyTo({
                    center: seattleCenter,
                    zoom: 11
                });
                
                // Reset button
                useLocationBtn.textContent = "Use My Location";
                useLocationBtn.style.background = "white";
                useLocationBtn.style.color = "#1e90ff";
                
                // Update filter if radius is active
                if (currentRadius > 0 && allParksData) {
                    const filteredParks = filterParksByRadius(allParksData, userLocation, currentRadius);
                    updateFilteredParks(filteredParks);
                    filterStatus.textContent = `Showing ${filteredParks.features.length} parks within ${currentRadius.toFixed(1)} miles`;
                } else if (allParksData) {
                    updateFilteredParks(allParksData);
                    filterStatus.textContent = "Showing all parks";
                }
                return;
            }
            
            // Otherwise, get user's location
            if (navigator.geolocation) {
                useLocationBtn.textContent = "Getting location...";
                useLocationBtn.disabled = true;
                
                navigator.geolocation.getCurrentPosition(
                    function(position) {
                        userLocation = [position.coords.longitude, position.coords.latitude];
                        locationExplicitlySet = true;
                        useLocationBtn.textContent = "Clear Location";
                        useLocationBtn.style.background = "#e74c3c";
                        useLocationBtn.style.color = "white";
                        
                        // Nur: Add user location marker
                        updateUserLocationMarker(userLocation);
                        
                        // Center map on user location
                        map.flyTo({
                            center: userLocation,
                            zoom: 12
                        });
                        
                        // Apply current radius filter
                        if (currentRadius > 0 && allParksData) {
                            const filteredParks = filterParksByRadius(allParksData, userLocation, currentRadius);
                            updateFilteredParks(filteredParks);
                            filterStatus.textContent = `Showing ${filteredParks.features.length} parks within ${currentRadius.toFixed(1)} miles`;
                        }
                        // Update all distances shown in the table
                        updateAllDistances(userLocation);
                        
                        useLocationBtn.disabled = false;
                    },
                    function(error) {
                        console.error("Error getting location:", error);
                        useLocationBtn.textContent = "Location Error";
                        useLocationBtn.style.background = "#e74c3c";
                        useLocationBtn.style.color = "white";
                        
                        // Fallback to map center (no marker shown for fallback)
                        userLocation = map.getCenter().toArray();
                        locationExplicitlySet = false;
                        updateAllDistances(userLocation);
                        
                        setTimeout(() => {
                            useLocationBtn.textContent = "Use My Location";
                            useLocationBtn.style.background = "white";
                            useLocationBtn.style.color = "#1e90ff";
                            useLocationBtn.disabled = false;
                        }, 2000);
                    }
                );
            } else {
                alert("Geolocation is not supported by your browser. Using map center as reference.");
                userLocation = map.getCenter().toArray();
                updateAllDistances(userLocation);
                locationExplicitlySet = false;
            }
        });

        // Update location when map center changes (if user manually moves map)
        map.on('moveend', function() {
            // Only update if user hasn't set their location explicitly
            // We'll track this with a flag, but for simplicity, we'll use map center
            // when radius filter is active and no explicit location was set
            if (currentRadius > 0 && userLocation) {
                // Optionally update to new center, or keep user's set location
                // For now, we'll keep the user's set location unless they click the button again
            }
        });
        // Nur: Radius filter feature end
    </script>

</body>
</html>
